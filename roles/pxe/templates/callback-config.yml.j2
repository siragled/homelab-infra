#!/usr/bin/env python3
"""
{{ organization_name }} - PXE Callback Service
Handles post-installation callbacks from newly provisioned nodes
Generated by Ansible - do not edit manually
"""

import asyncio
import logging
import yaml
import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel, Field
import uvicorn

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('{{ callback_log_file }}'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="{{ organization_name }} PXE Callback Service",
    description="Handles callbacks from newly provisioned nodes",
    version="1.0.0"
)

# Configuration
CONFIG_FILE = Path("/opt/pxe-callback/config.yml")
INVENTORY_FILE = Path("{{ callback_inventory_file }}")

class NodeInfo(BaseModel):
    hostname: str = Field(..., description="Node hostname")
    mac_address: str = Field(..., description="Primary MAC address") 
    ip_address: str = Field(..., description="Current IP address")
    architecture: str = Field(..., description="CPU architecture (amd64/arm64)")
    os_version: str = Field(..., description="Installed OS version")
    installation_id: str = Field(..., description="Unique installation ID")
    hardware_info: Optional[Dict] = Field(default={}, description="Additional hardware details")
    timestamp: Optional[datetime] = Field(default_factory=lambda: datetime.now(timezone.utc))

class CallbackResponse(BaseModel):
    status: str
    message: str
    next_steps: List[str] = []

def load_config() -> Dict:
    """Load callback service configuration"""
    try:
        with open(CONFIG_FILE) as f:
            return yaml.safe_load(f)
    except Exception as e:
        logger.error(f"Failed to load config: {e}")
        return {}

def load_inventory() -> Dict:
    """Load current Ansible inventory"""
    try:
        if INVENTORY_FILE.exists():
            with open(INVENTORY_FILE) as f:
                return yaml.safe_load(f) or {}
        return {"all": {"children": {}}}
    except Exception as e:
        logger.error(f"Failed to load inventory: {e}")
        return {"all": {"children": {}}}

def save_inventory(inventory: Dict) -> bool:
    """Save updated Ansible inventory"""
    try:
        INVENTORY_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(INVENTORY_FILE, 'w') as f:
            yaml.dump(inventory, f, default_flow_style=False, indent=2)
        logger.info(f"Updated inventory saved to {INVENTORY_FILE}")
        return True
    except Exception as e:
        logger.error(f"Failed to save inventory: {e}")
        return False

def add_node_to_inventory(node: NodeInfo) -> bool:
    """Add newly provisioned node to Ansible inventory"""
    config = load_config()
    auto_add = config.get('auto_add_to_inventory', {{ auto_add_to_inventory | lower }})
    
    if not auto_add:
        logger.info(f"Auto-add disabled, skipping inventory update for {node.hostname}")
        return True
    
    inventory = load_inventory()
    
    # Ensure required groups exist
    default_groups = config.get('default_node_groups', {{ default_node_groups | to_json }})
    
    for group_name in default_groups:
        if group_name not in inventory.get('all', {}).get('children', {}):
            inventory.setdefault('all', {}).setdefault('children', {})[group_name] = {
                'hosts': {}
            }
    
    # Add architecture-specific group
    arch_group = f"arch_{node.architecture}"
    if arch_group not in inventory['all']['children']:
        inventory['all']['children'][arch_group] = {'hosts': {}}
    
    # Node configuration
    node_config = {
        'ansible_host': node.ip_address,
        'ansible_user': 'admin',
        'pxe_provisioned': True,
        'pxe_installation_id': node.installation_id,
        'pxe_provisioned_at': node.timestamp.isoformat(),
        'hardware': {
            'mac_address': node.mac_address,
            'architecture': node.architecture,
            'os_version': node.os_version,
            **node.hardware_info
        }
    }
    
    # Add to groups
    for group_name in default_groups + [arch_group]:
        inventory['all']['children'][group_name]['hosts'][node.hostname] = node_config
    
    return save_inventory(inventory)

@app.get("/")
async def root():
    """Service health check"""
    return {
        "service": "{{ organization_name }} PXE Callback Service",
        "status": "running",
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

@app.get("/health")
async def health():
    """Detailed health check"""
    config = load_config()
    return {
        "status": "healthy",
        "inventory_file": str(INVENTORY_FILE),
        "inventory_exists": INVENTORY_FILE.exists(),
        "config_loaded": bool(config),
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

@app.post("/register", response_model=CallbackResponse)
async def register_node(node: NodeInfo, request: Request):
    """Register a newly provisioned node"""
    client_ip = request.client.host
    logger.info(f"Registration request from {client_ip}: {node.hostname} ({node.mac_address})")
    
    try:
        # Add to inventory
        if add_node_to_inventory(node):
            next_steps = [
                "Node added to Ansible inventory",
                "SSH key distribution will begin shortly",
                "Monitoring agent installation scheduled"
            ]
            
            logger.info(f"Successfully registered node: {node.hostname}")
            
            return CallbackResponse(
                status="success",
                message=f"Node {node.hostname} registered successfully",
                next_steps=next_steps
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to update inventory")
            
    except Exception as e:
        logger.error(f"Registration failed for {node.hostname}: {e}")
        raise HTTPException(status_code=500, detail=f"Registration failed: {str(e)}")

@app.get("/nodes")
async def list_nodes():
    """List all registered nodes"""
    inventory = load_inventory()
    nodes = []
    
    for group_name, group_data in inventory.get('all', {}).get('children', {}).items():
        if group_name == 'pxe-provisioned':
            for hostname, host_data in group_data.get('hosts', {}).items():
                nodes.append({
                    'hostname': hostname,
                    'ip_address': host_data.get('ansible_host'),
                    'mac_address': host_data.get('hardware', {}).get('mac_address'),
                    'architecture': host_data.get('hardware', {}).get('architecture'),
                    'provisioned_at': host_data.get('pxe_provisioned_at')
                })
    
    return {"nodes": nodes, "count": len(nodes)}

if __name__ == "__main__":
    uvicorn.run(
        "app:app",
        host="{{ callback_api_host }}",
        port={{ callback_api_port }},
        reload=False,
        access_log=True
    )
